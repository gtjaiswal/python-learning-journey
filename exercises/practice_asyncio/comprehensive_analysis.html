<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Concurrency Benchmark Analysis</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        h1 {
            color: white;
            text-align: center;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 30px;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h2 {
            color: #2c3e50;
            border-left: 6px solid #3498db;
            padding-left: 15px;
            margin-top: 0;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .result-card {
            padding: 20px;
            border-radius: 8px;
            border: 3px solid;
            text-align: center;
        }
        
        .result-card h4 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .result-card .time {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .result-worst {
            background: #ffe5e5;
            border-color: #e74c3c;
        }
        
        .result-medium {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        .result-best {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .highlight {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .highlight strong {
            color: #856404;
            font-size: 1.2em;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        .comparison-table td {
            padding: 12px;
            border: 1px solid #ddd;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .speedup-good { color: #28a745; font-weight: bold; }
        .speedup-bad { color: #e74c3c; font-weight: bold; }
        
        .timeline {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .timeline-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        
        .timeline-label {
            width: 100px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .timeline-bar {
            flex: 1;
            display: flex;
            gap: 5px;
        }
        
        .bar-segment {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .bar-io {
            background: #3498db;
            color: white;
        }
        
        .bar-cpu {
            background: #e74c3c;
            color: white;
        }
        
        .bar-idle {
            background: #ecf0f1;
            color: #7f8c8d;
        }
        
        .insight-box {
            background: #e8f8f5;
            border: 3px solid #27ae60;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .insight-box h3 {
            margin-top: 0;
            color: #27ae60;
        }
        
        .warning-box {
            background: #ffe5e5;
            border: 3px solid #e74c3c;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .warning-box h3 {
            margin-top: 0;
            color: #e74c3c;
        }
        
        .code-inline {
            background: #282c34;
            color: #61afef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>üìä Complete Concurrency Benchmark Analysis</h1>
    
    <!-- CPU-BOUND RESULTS -->
    <div class="section">
        <h2>üßÆ Part 1: CPU-Bound Tasks (Prime Calculation)</h2>
        
        <div class="results-grid">
            <div class="result-card result-medium">
                <h4>Sequential</h4>
                <div class="time">0.31s</div>
                <div>Baseline</div>
            </div>
            <div class="result-card result-worst">
                <h4>ThreadPool</h4>
                <div class="time">0.37s</div>
                <div class="speedup-bad">1.19x SLOWER</div>
            </div>
            <div class="result-card result-best">
                <h4>ProcessPool</h4>
                <div class="time">0.18s</div>
                <div class="speedup-good">1.74x FASTER</div>
            </div>
            <div class="result-card result-worst">
                <h4>asyncio.to_thread</h4>
                <div class="time">0.40s</div>
                <div class="speedup-bad">1.29x SLOWER</div>
            </div>
            <div class="result-card result-worst">
                <h4>Native async</h4>
                <div class="time">0.31s</div>
                <div class="speedup-bad">No benefit</div>
            </div>
        </div>
        
        <div class="warning-box">
            <h3>‚ö†Ô∏è Critical Lesson: CPU-Bound Work</h3>
            <ul style="font-size: 1.05em;">
                <li><strong>ThreadPoolExecutor:</strong> WORSE than sequential due to GIL + context switching overhead</li>
                <li><strong>asyncio.to_thread:</strong> Same as ThreadPoolExecutor (uses thread pool internally)</li>
                <li><strong>Native async:</strong> Blocks event loop, runs sequentially despite <code class="code-inline">await asyncio.sleep(0)</code></li>
                <li><strong>ProcessPoolExecutor:</strong> ONLY option that provides speedup (bypasses GIL)</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>üéØ Key Takeaway:</strong><br>
            For CPU-bound work, ONLY <code class="code-inline">ProcessPoolExecutor</code> helps. 
            Threads and async provide zero benefit due to the GIL!
        </div>
    </div>

    <!-- I/O-BOUND RESULTS -->
    <div class="section">
        <h2>üåê Part 2: I/O-Bound Tasks (Simulated Network Requests)</h2>
        
        <div class="results-grid">
            <div class="result-card result-worst">
                <h4>Sequential</h4>
                <div class="time">4.00s</div>
                <div>Baseline</div>
            </div>
            <div class="result-card result-best">
                <h4>ThreadPool</h4>
                <div class="time">1.00s</div>
                <div class="speedup-good">4.0x FASTER</div>
            </div>
            <div class="result-card result-best">
                <h4>Asyncio</h4>
                <div class="time">1.00s</div>
                <div class="speedup-good">4.0x FASTER</div>
            </div>
        </div>
        
        <div class="timeline">
            <h3 style="margin-top: 0;">Timeline Comparison</h3>
            
            <div class="timeline-row">
                <div class="timeline-label">Sequential</div>
                <div class="timeline-bar">
                    <div class="bar-segment bar-io" style="flex: 1;">URL1 (1s)</div>
                    <div class="bar-segment bar-io" style="flex: 1;">URL2 (1s)</div>
                    <div class="bar-segment bar-io" style="flex: 1;">URL3 (1s)</div>
                    <div class="bar-segment bar-io" style="flex: 1;">URL4 (1s)</div>
                </div>
            </div>
            
            <div class="timeline-row">
                <div class="timeline-label">ThreadPool</div>
                <div class="timeline-bar">
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                        <div class="bar-segment bar-io">URL1</div>
                        <div class="bar-segment bar-io">URL2</div>
                        <div class="bar-segment bar-io">URL3</div>
                        <div class="bar-segment bar-io">URL4</div>
                    </div>
                    <div class="bar-segment bar-idle" style="flex: 3;">All waiting concurrently (1s total)</div>
                </div>
            </div>
            
            <div class="timeline-row">
                <div class="timeline-label">Asyncio</div>
                <div class="timeline-bar">
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                        <div class="bar-segment bar-io">URL1</div>
                        <div class="bar-segment bar-io">URL2</div>
                        <div class="bar-segment bar-io">URL3</div>
                        <div class="bar-segment bar-io">URL4</div>
                    </div>
                    <div class="bar-segment bar-idle" style="flex: 3;">All waiting concurrently (1s total)</div>
                </div>
            </div>
        </div>
        
        <div class="insight-box">
            <h3>‚úÖ Perfect Use Case for Concurrency</h3>
            <ul style="font-size: 1.05em;">
                <li><strong>ThreadPoolExecutor:</strong> Each thread waits for I/O, other threads can run</li>
                <li><strong>Asyncio:</strong> Event loop switches between tasks while waiting for I/O</li>
                <li><strong>Both achieve ~4x speedup</strong> - all 4 requests happen concurrently</li>
                <li><strong>Asyncio has lower overhead</strong> than threads (single-threaded, no context switching)</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>üéØ Key Takeaway:</strong><br>
            For I/O-bound work, both threads and asyncio work great! 
            Asyncio is typically preferred for its lower overhead and scalability.
        </div>
    </div>

    <!-- MIXED WORKLOAD RESULTS -->
    <div class="section">
        <h2>üîÄ Part 3: Mixed I/O + CPU Workload</h2>
        
        <div class="results-grid">
            <div class="result-card result-worst">
                <h4>Naive Async<br>(blocks event loop)</h4>
                <div class="time">1.21s</div>
                <div>CPU work blocks!</div>
            </div>
            <div class="result-card result-best">
                <h4>Optimized<br>(with ProcessPool)</h4>
                <div class="time">1.12s</div>
                <div class="speedup-good">1.08x FASTER</div>
            </div>
        </div>
        
        <div class="timeline">
            <h3 style="margin-top: 0;">Execution Flow Comparison</h3>
            
            <div style="margin: 20px 0;">
                <h4>‚ùå Naive Approach (Blocking Event Loop)</h4>
                <div class="timeline-row">
                    <div class="timeline-label">Time 0-1s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-io" style="flex: 1;">All 4 fetch concurrently (I/O)</div>
                    </div>
                </div>
                <div class="timeline-row">
                    <div class="timeline-label">Time 1-1.2s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-cpu" style="flex: 1;">Process URL1 (CPU blocks!)</div>
                    </div>
                </div>
                <div class="timeline-row">
                    <div class="timeline-label">Time 1.2-1.4s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-cpu" style="flex: 1;">Process URL2 (CPU blocks!)</div>
                    </div>
                </div>
                <div class="timeline-row">
                    <div class="timeline-label">Time 1.4-1.6s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-cpu" style="flex: 1;">Process URL3 (CPU blocks!)</div>
                    </div>
                </div>
                <div class="timeline-row">
                    <div class="timeline-label">Time 1.6-1.8s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-cpu" style="flex: 1;">Process URL4 (CPU blocks!)</div>
                    </div>
                </div>
                <p style="margin-top: 15px; color: #e74c3c;"><strong>Problem:</strong> CPU work runs sequentially, blocking the event loop each time!</p>
            </div>
            
            <div style="margin: 30px 0;">
                <h4>‚úÖ Optimized Approach (with ProcessPoolExecutor)</h4>
                <div class="timeline-row">
                    <div class="timeline-label">Time 0-1s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-io" style="flex: 1;">All 4 fetch concurrently (I/O)</div>
                    </div>
                </div>
                <div class="timeline-row">
                    <div class="timeline-label">Time 1-1.12s</div>
                    <div class="timeline-bar">
                        <div class="bar-segment bar-cpu" style="flex: 1;">All 4 process in parallel (separate processes)</div>
                    </div>
                </div>
                <p style="margin-top: 15px; color: #28a745;"><strong>Solution:</strong> CPU work delegated to processes, runs in parallel!</p>
            </div>
        </div>
        
        <div class="warning-box">
            <h3>‚ö†Ô∏è Common Mistake: Blocking the Event Loop</h3>
            <p style="font-size: 1.05em;">In the naive approach:</p>
            <pre style="background: #282c34; color: #abb2bf; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>async def fetch_and_process_naive(url):
    data = await fetch_data_async(url)  # ‚úÖ Good - async I/O
    cpu_bound_operation(data)           # ‚ùå BAD - blocks event loop!
    # Event loop FROZEN during CPU work
    # Other tasks can't run</code></pre>
            
            <p style="font-size: 1.05em; margin-top: 20px;">The fix:</p>
            <pre style="background: #282c34; color: #abb2bf; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>async def fetch_and_process_optimized(executor, url):
    data = await fetch_data_async(url)  # ‚úÖ Good - async I/O
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(        # ‚úÖ Good - CPU in process
        executor, 
        cpu_bound_operation, 
        data
    )
    # Event loop stays free!
    # Other tasks continue running</code></pre>
        </div>
        
        <div class="insight-box">
            <h3>‚úÖ Best Practice for Mixed Workloads</h3>
            <ol style="font-size: 1.05em; line-height: 1.8;">
                <li><strong>Use asyncio for I/O operations</strong> - handle network, file I/O with async libraries</li>
                <li><strong>Delegate CPU work to ProcessPoolExecutor</strong> - use <code class="code-inline">loop.run_in_executor()</code></li>
                <li><strong>Never block the event loop</strong> - avoid synchronous CPU-bound code in async functions</li>
                <li><strong>For light CPU work</strong> - can use ThreadPoolExecutor (less overhead than processes)</li>
            </ol>
        </div>
    </div>

    <!-- COMPREHENSIVE COMPARISON TABLE -->
    <div class="section">
        <h2>üìã Complete Comparison Table</h2>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Approach</th>
                    <th>CPU-Bound<br>(0.31s baseline)</th>
                    <th>I/O-Bound<br>(4.00s baseline)</th>
                    <th>Mixed Workload<br>(I/O + CPU)</th>
                    <th>Best Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Sequential</strong></td>
                    <td>0.31s (baseline)</td>
                    <td>4.00s (slow)</td>
                    <td>~5.2s (if done sequentially)</td>
                    <td>Simple scripts, prototypes</td>
                </tr>
                <tr>
                    <td><strong>ThreadPoolExecutor</strong></td>
                    <td style="background: #ffe5e5;">0.37s <span class="speedup-bad">(worse!)</span></td>
                    <td style="background: #d4edda;">1.00s <span class="speedup-good">(4.0x)</span></td>
                    <td>Good for I/O, bad for CPU</td>
                    <td>I/O-bound blocking libraries</td>
                </tr>
                <tr>
                    <td><strong>ProcessPoolExecutor</strong></td>
                    <td style="background: #d4edda;">0.18s <span class="speedup-good">(1.74x)</span></td>
                    <td style="background: #fff3cd;">Overkill (high overhead)</td>
                    <td style="background: #d4edda;">1.12s <span class="speedup-good">(best!)</span></td>
                    <td>CPU-bound work, mixed workloads</td>
                </tr>
                <tr>
                    <td><strong>asyncio.to_thread</strong></td>
                    <td style="background: #ffe5e5;">0.40s <span class="speedup-bad">(worse!)</span></td>
                    <td style="background: #d4edda;">~1.00s <span class="speedup-good">(4.0x)</span></td>
                    <td>Same as ThreadPoolExecutor</td>
                    <td>Integrating blocking I/O with asyncio</td>
                </tr>
                <tr>
                    <td><strong>Native asyncio</strong></td>
                    <td style="background: #ffe5e5;">0.31s <span class="speedup-bad">(no help)</span></td>
                    <td style="background: #d4edda;">1.00s <span class="speedup-good">(4.0x)</span></td>
                    <td style="background: #d4edda;">Best for I/O part</td>
                    <td>I/O-bound with async libraries</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- DECISION GUIDE -->
    <div class="section">
        <h2>üéØ Decision Guide: What to Use When</h2>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
            <div style="background: #e8f8f5; border: 3px solid #27ae60; border-radius: 10px; padding: 25px;">
                <h3 style="margin-top: 0; color: #27ae60;">üåê Pure I/O-Bound</h3>
                <p><strong>Scenario:</strong> Web scraping, API calls, database queries</p>
                <p><strong>Best Choice:</strong> <code class="code-inline">asyncio</code> with async libraries (aiohttp, asyncpg)</p>
                <p><strong>Alternative:</strong> <code class="code-inline">ThreadPoolExecutor</code> if stuck with blocking libraries</p>
                <p><strong>Why:</strong> Lowest overhead, scales to thousands of concurrent operations</p>
            </div>
            
            <div style="background: #fef5e7; border: 3px solid #f39c12; border-radius: 10px; padding: 25px;">
                <h3 style="margin-top: 0; color: #f39c12;">üßÆ Pure CPU-Bound</h3>
                <p><strong>Scenario:</strong> Data processing, image manipulation, ML inference</p>
                <p><strong>Best Choice:</strong> <code class="code-inline">ProcessPoolExecutor</code></p>
                <p><strong>Why:</strong> Only way to bypass GIL and use multiple CPU cores</p>
                <p><strong>Note:</strong> Has overhead - only worth it for substantial work</p>
            </div>
            
            <div style="background: #ebf5fb; border: 3px solid #3498db; border-radius: 10px; padding: 25px;">
                <h3 style="margin-top: 0; color: #3498db;">üîÄ Mixed I/O + CPU</h3>
                <p><strong>Scenario:</strong> Fetch data, then process it; web scraping + parsing</p>
                <p><strong>Best Choice:</strong> <code class="code-inline">asyncio</code> for I/O + <code class="code-inline">ProcessPoolExecutor</code> for CPU</p>
                <p><strong>Pattern:</strong> <code class="code-inline">await loop.run_in_executor()</code></p>
                <p><strong>Why:</strong> Combines benefits of both approaches</p>
            </div>
        </div>
    </div>

    <!-- KEY INSIGHTS -->
    <div class="section">
        <h2>üí° Key Insights from the Benchmarks</h2>
        
        <div class="highlight">
            <strong>1. The GIL Makes Threads Useless for CPU Work</strong><br>
            ThreadPoolExecutor was 19% SLOWER than sequential execution for CPU-bound work. 
            The GIL forces threads to run one at a time, and context switching adds overhead.
        </div>
        
        <div class="highlight">
            <strong>2. Asyncio Doesn't Magically Parallelize CPU Work</strong><br>
            Adding <code class="code-inline">await asyncio.sleep(0)</code> in CPU-bound code doesn't help - 
            the CPU work still runs sequentially in the event loop. Native async performed identically to sequential.
        </div>
        
        <div class="highlight">
            <strong>3. I/O-Bound: Threads and Asyncio Both Work Great</strong><br>
            Both achieved 4x speedup for I/O-bound work. Asyncio is typically preferred due to 
            lower overhead and better scalability to thousands of concurrent operations.
        </div>
        
        <div class="highlight">
            <strong>4. Mixed Workloads Need Careful Design</strong><br>
            Never put CPU-bound code directly in async functions - it blocks the event loop! 
            Always delegate to executors using <code class="code-inline">run_in_executor()</code>.
        </div>
        
        <div class="highlight">
            <strong>5. ProcessPoolExecutor is the ONLY Way for CPU Parallelism</strong><br>
            For CPU-bound work, ProcessPoolExecutor achieved 1.74x speedup by using multiple cores. 
            Every other approach was sequential due to the GIL.
        </div>
    </div>

    <!-- INTERVIEW PREP -->
    <div class="section">
        <h2>üéì Interview-Ready Explanations</h2>
        
        <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 10px; padding: 25px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Q: "When would you use asyncio vs threading vs multiprocessing?"</h3>
            <p style="font-size: 1.05em;"><strong>Answer:</strong></p>
            <ul style="font-size: 1.05em; line-height: 1.8;">
                <li><strong>Asyncio:</strong> For I/O-bound work with async libraries (aiohttp, asyncpg). Lowest overhead, scales to thousands of concurrent operations. Event loop switches between tasks while waiting for I/O.</li>
                <li><strong>Threading (ThreadPoolExecutor):</strong> For I/O-bound work with blocking libraries (requests, psycopg2). Threads yield during I/O waits, allowing other threads to run.</li>
                <li><strong>Multiprocessing (ProcessPoolExecutor):</strong> For CPU-bound work (data processing, ML inference). Each process has its own Python interpreter and GIL, enabling true parallel execution on multiple CPU cores.</li>
            </ul>
        </div>
        
        <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 10px; padding: 25px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Q: "Why don't threads help with CPU-bound work in Python?"</h3>
            <p style="font-size: 1.05em;"><strong>Answer:</strong></p>
            <p style="font-size: 1.05em;">Because of the GIL (Global Interpreter Lock), which ensures only one thread can execute Python bytecode at a time. Even on a multi-core CPU with multiple threads, they execute sequentially for CPU-bound tasks. The GIL prevents race conditions in Python's memory management, but it also prevents CPU parallelism with threads. For true CPU parallelism, we need separate processes, each with its own Python interpreter and GIL.</p>
        </div>
        
        <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 10px; padding: 25px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Q: "How do you handle a mixed workload of I/O and CPU-bound operations?"</h3>
            <p style="font-size: 1.05em;"><strong>Answer:</strong></p>
            <p style="font-size: 1.05em;">I use asyncio for the I/O operations and delegate CPU-bound work to a ProcessPoolExecutor. The pattern is: handle I/O with async/await, then use <code class="code-inline">loop.run_in_executor(executor, cpu_func, data)</code> to run CPU work in a separate process. This keeps the event loop responsive during I/O while achieving parallelism for CPU work. The key is never putting CPU-bound code directly in async functions, as that blocks the event loop.</p>
        </div>
    </div>

</body>
</html>